1. https://www.cnblogs.com/yonglin/p/8080836.html
    //单例模式抽象，分离创建对象的函数和判断对象是否已经创建
    var getSingle = function (fn) {
        var result;
        return function () {
            return result || ( result = fn.apply(this, arguments) );
        }
    };
    形参fn是我们的构造函数，我们只要传入任何自己需要的构造函数，就能生成一个新的惰性单例。比如说传入创建一个女朋友的构造函数，并且调用getSingle(),就能生成一个新的女朋友。如果以后再调getSingle(),也只会返回刚才创建的那个女朋友。至于新女朋友——不存在的。

2. node的复制方法：
   function cpdir(oldDirPath, newDirPath) {
    const fs = require("fs");
    return new Promise(function (resolve, reject) {
      fs.mkdir(newDirPath, (err) => {
        reject(err);
      });
      console.log(oldDirPath, newDirPath);
      fs.readdir(oldDirPath, (err, list) => {
        if (err) {
          reject(err);
        } else {
          resolve(list);
          list.forEach((item) => {
            console.log("list", list, item);
            fs.stat(oldDirPath + "/\\" + item, (err, stats) => {
              if (stats.isFile()) {
                fs.copyFile(
                  oldDirPath + "/\\" + item,
                  newDirPath + "/\\" + item,
                  (err) => {
                    console.log("copyError:", err);
                  }
                );
              } else {
                oldDirPath += "/\\" + item;
                newDirPath += "/\\" + item;
                cpdir(oldDirPath, newDirPath);
              }
            });
          });
        }
      });
    });
  }
    cpdir("D:\\lk\\java\\javaNote", "d:\\QQ");